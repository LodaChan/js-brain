# GC内存回收机制

> Chrome浏览器限制的所能使用的内存极限（64位为1.4GB，32位为1.0GB）

#### 一、内存回收方式

+ 标记清除
+ 引用计数

#### 二、标记清除

+ 作用域中的 活动对象 `[[scoped]]` 计数实现计数
+ var obj = null 

#### 三、引用计数

#### 四、细讲V8

通过向下移动 ESP(记录当前执行状态的指针) 来销毁该函数保存在栈中的执行上下文

> V8 中会把堆分为`新生代`和`老生代`两个区域 , 新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象,`新生区`通常只支持 1～8M 的容量

V8 分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收。

+ `副垃圾回收器`，`新生代`的垃圾回收。
   + Scavenge 算法 ， 对半翻转
+ `主垃圾回收器`，`老生代`的垃圾回收。
   + 标记 - 清除（Mark-Sweep）
   + 标记 - 整理（Mark-Compact）向一端移动
   + 增量标记（Incremental Marking）切分成小任务，回收与js执行循环执行

#### 五、执行过程

#### 非活动对象 一般处理流程

+ 标记空间中 活动对象 和 非活动对象
+ 回收非活动对象所占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象
+ 内存整理
```
存在大量不连续空间,也叫内存碎片

如果需要分配较大连续内存的时候，就有可能出现内存不足的情况
```

#### 新生代内存回收

> `Scavenge` 对半切分翻转算法, 对半划分为两个区域，一半是对象区域，一半是空闲区域,新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作

+ 标记；标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序地排列起来，所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了

+ 对象区域 与 空闲区域 翻转 ， 并进行内存回收

+ 对象晋升策略,也就是经过两次垃圾回收依然还存活的对象，会被移动到老生代中

#### 老生代内存回收


> 标记 - 清除（Mark-Sweep）算法

+ 就是从上往下看 活动对象的 scoped 属性进行计数
+ scoped计数为0的判定为垃圾数据，进行回收

> 标记 - 整理（Mark-Compact）算法

+ 当 垃圾数据 被回收后内存是不连续的
+ 让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存，从而让存活对象占用连续的内存块



#### 六、页面卡顿与全停顿

+ 全停顿

> js运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行 , 这种情况就是全停顿

+ 比如页面正在执行一个 JavaScript 动画，因为垃圾回收器在工作，就会导致这个动画在垃圾回收过程中无法执行，这将会造成页面的卡顿现象

> 增量标记（Incremental Marking）算法  ,为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成

把一个完整的垃圾回收任务拆分为很多小的任务，这些小的任务执行时间比较短，可以穿插在其他的 JavaScript 任务中间执行，这样当执行上述动画效果时，就不会让用户因为垃圾回收任务而感受到页面的卡顿了，这就是`V8看起来快，不卡顿的原因`