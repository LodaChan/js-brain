# 闭包closure

> 一个函数可以访问另一个函数作用域中变量

外部函数的内部函数被外部函数外的一个变量引用

+ 一个函数 并返回 一个嵌套函数
+ 内部函数执行时可以引用外层的变量
+ 形成一个不销毁的作用域



#### 具体细节

+ 外部函数的 变量 随调用参数变量 单独存储
+ 外部函数的 属性 会暴露到window中


#### 使用场景

+ 对变量进行私有保护
+ 函数柯里化


#### 具体过程

+ 当定义函数a的时候，js解释器会将函数a的作用域链（scope chain）设置为定义a时a所在的“环境”，如果a是一个全局函数，则scope chain中只有window对象。

+ 当函数a执行的时候，a会进入相应的执行环境（execution context）。

+ 在创建执行环境的过程中，首先会为a添加一个scope属性，即a的作用域，其值就为第1步中的scope chain。即a.scope=a的作用域链

+ 然后执行环境会创建一个活动对象（call object）。活动对象也是一个拥有属性的对象，但它不具有原型而且不能通过JavaScript代码直接访问。创建完活动对象后，把活动对象添加到a的作用域链的最顶端。此时a的作用域链包含了两个对象：a的活动对象和window对象。

+ 下一步是在活动对象上添加一个arguments属性，它保存着调用函数a时所传递的参数。

+ 最后把所有函数a的形参和内部的函数b的引用也添加到a的活动对象上。在这一步中，完成了函数b的的定义，因此如同第3步，函数b的作用域链被设置为b所被定义的环境，即a的作用域。

+ 到此，整个函数a从定义到执行的步骤就完成了。此时a返回函数b的引用给c，又函数b的作用域链包含了对函数a的活动对象的引用，也就是说b可以访问到a中定义的所有变量和函数。函数b被c引用，函数b又依赖函数a，因此函数a在返回后不会被GC回收。

+ 当函数b执行的时候亦会像以上步骤一样。因此，执行时b的作用域链包含了3个对象：b的活动对象、a的活动对象和window对象，

+ 当在函数b中访问一个变量的时候，搜索顺序是先搜索自身的活动对象，如果存在则返回，如果不存在将继续搜索函数a的活动对象，依次查找，直到找到为止。如果整个作用域链上都无法找到，则返回undefined。如果函数b存在prototype原型对象，则在查找完自身的活动对象 后先查找自身的原型对象，再继续查找。这就是Javascript中的变量查找机制
